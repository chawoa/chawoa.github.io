---
title: AI 알고리즘 1주차
date: 2024-09-07 15:26:38 +09:00
categories: [3학년 2학기, AI 알고리즘]
tags: [단기 계획, 3학년 2학기, AI 알고리즘]
---

이번 글에선 AI 알고리즘 1주차 내용인 '이분법'에 대해 설명해드리려고 합니다.

우리가 흔히 AI라고 부르는 기술을 만드는 과정은 딥러닝을 활용하여 **최적의 해를 찾을 수 있는 정답에 가까운 방정식을 찾아가는 것**입니다.

이때 **'정답에 가까운'**이라는 표현이 중요한데요, 사용자가 정답을 찾길 바라는 어떤 문제에 대한 답은 어떠한 특정 방정식을 만족한다는 사실을 제외하고는 정보가 거의 없는 '수'일 때가 많습니다. (여기서 '입력값이 문자면?'이라는 의문점을 가지실수도 있는데, 실제로 모델을 만드는 과정에서 입력값이 문자일 경우 해당 문자를 수의 형태로 '인코딩(Encoding)'하여 알고리즘에서 사용합니다)

따라서 정보가 부족했던 수를 마치 정보가 있는 것처럼, 즉 **'정답은 아니지만 그와 유사한 형태'**로 만듦으로써 예측할 수 있는 상태로 만드는 작업이 필요합니다. 그 방법 중 하나가 바로 **'이분법'**입니다.

이분법은 함수의 구간을 정하고, 해당 구간의 중간값을 설정하여 **'f(r) = 0'**을 만족하는 실수 r값을 찾아가는 과정 또는 그 방법을 의미합니다.

이때 조건 및 과정은 간략히 다음과 같습니다.

## **이분법**

1. 함수 f가 어떤 구간에서 연속이며 구간의 양 끝점에서 서로 다른 부호의 함숫값을 가진다.
   → **'a ＜ b' 일 때 'f(a)f(b) ＜ 0'**
2. f는 구간 (a,b)에서 근을 가진다.
3. 즉, 두 조건 **'a ＜ r ＜ b'와 'f(r) = 0'을 만족하는 실수 r이 반드시 존재**한다.

![Desktop View](/assets/img/math/bisection.jpg){: width="500" height="500" }

이분법이라는 용어 자체가 어색하실 수 있는데요, 이 방식은 **'사잇값 정리'**를 기반으로 합니다.

## **사잇값 정리**

**'a ≤ r ≤ b'** 인 폐구간에서 r이 움직일 때 f(r)은 f(a)와 f(b)사이의 구간을 빠짐없이 채우게 됩니다. 이때 r이 연속적이므로 f(r) 값 또한 연속적이게 되어 이산적인 형태는 존재하지 않습니다. 이러한 상황에서 f(a)와 f(b)는 부호가 서로 반대이기 때문에 **함수 f는 a ≤ r ≤ b 어딘가에서 반드시 0이 되는 r값이 존재**하게 됩니다.

이분법은 이렇게 연속함수의 속성을 활용한 것인데요, 이를 알고리즘으로 표현할 수 있습니다.

## **이분법 알고리즘**

- 알고리즘의 각 단계에서 **구간 [a, b]와 fa = f(a), fb = f(b)**가 주어진다.
- 이때 fa, fb는 **「fa \* fb ＜ 0」을 만족**한다.
- 위의 **폐구간의 중점인 「c = 1/2(a + b)」**를 정하고, **fc = f(c)**를 구한다.
- 우연히 f(c) = 0이라면 이 알고리즘의 목적은 달성된 것이다.
- 그러나, 대부분의 경우는 **「fc ≠ 0」**이고 이때 **「fc \* fa ＜ 0 또는 fc \* fb ＜ 0」**이다.

주의할 점은 일반적으로 임의로 주어진 함수의 근을 찾는 과정에서 불필요한 함수의 계산을 피하는 것이 좋은데, 이는 해당 함수를 계산할 때 시간 복잡도 개념에서 **'같은 결과를 도출하는 연산의 반복 작업'이 매 실행마다 포함될 수 있기 때문**입니다. 따라서 이후에 필요한 함수 값은 미리 저장해놓는 **'동적 프로그래밍(Dynamic Programming)'**의 개념을 사용하면 위와 같은 문제를 예방할 수 있습니다.

## **수렴성**

앞서 말한 바와 같이 이분법은 답과 유사한 값을 찾아가는 과정이기 때문에 오차가 발생하게 되는데, 이에 따라 필연적으로 **'정확도'**라는 개념이 따라옵니다.

![Desktop View](/assets/img/math/convergence.jpg){: width="500" height="500" }

## 가정

1. f가 구간 [a0, b0]의 양 끝에서 서로 다른 부호의 함숫값을 갖는 연속함수라고 가정
2. [a0, b0] 내에 한 근 r이 존재. 중점 **「c0 = (a0 + b0) / 2」**를 근 r의 근삿값으로 하면 **「┃r - c0┃ ≤ (b0 - a0) / 2」**의 부등식을 얻을 수 있다.
3. 위의 식을 n회차로 일반화하면 각 단계마다 구간의 길이가 절반으로 줄어들기 때문에 최종적으로 **「┃r - cn┃ ≤ (bn - an) / 2^(n + 1)」**과 같은 부등식을 도출할 수 있다.

1주차 내용은 여기까지 입니다! 다음은 **'뉴턴법'**으로 돌아오겠습니다. 읽어주셔서 감사합니다!
